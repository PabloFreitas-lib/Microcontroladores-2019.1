#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

//----------------------------------------------------------//
#define ESC_REG(x)                  (*((volatile uint32_t *)(x)))
//--------------------------------------------------------------------------//
#define SYSCTL_RCGC2_GPIOF          0x00000020
#define SYSCTL_RCGCGPIO             0x400FE608
#define SYSCTL_RCGC2_R              0x400FE108
#define SYSCTL_RCGC2_GPIOF          0x00000020
#define GPIO_PORTF_DIR_R            0x40025400
#define GPIO_PORTF_DEN_R            0x4002551C
#define GPIO_PORTF_DATA_R           0x400253FC
#define RCC                         0x400FE060
#define RCC2                        0x400FE070
#define RCC_bypass                  1<<11 // ou 0x00000800
#define RCC_USESYSDIV               1<<22 // ou 0x00400000
#define RCC2_bypass2                1<<11 // ou 0x00000800
#define RCC_XTALM                   0x7C0
#define RCC_PIOSC                   0x10
#define RCC_OSCSRC                  0x30
#define RCC_XTAL_16MHZ              0x540 // 0x15<<6
#define RCC2_USERCC2                1<<31 // 0x80000000
#define RCC2_OSCSRCM                7<<4    // 0x70
#define RCC_PWRDN                   1<<13   // 0x2000
#define MISC                        0x400FE058
#define INT_PLL_LOCK                0x40
#define RCC_SYSDIV_M                0x07800000 // 0x1F<<23
#define RCC2_SYSDIV_M               0x1F800000
#define RCC2_DIV400                 1<<30
#define RIS                         0x400FE050
#define GPIO_O_ICR                  0x41C
//--------------------------------------------------------------------------//
#define config_80MHZ                0xC1000000      //RCC2
#define config_50MHZ                0x01C00000      // Divisao por 4 e usar o sysdiv
#define config_20MHZ                0x04C00000      // Divisao por 10 e usar o sysdiv
#define config_4MHZ                 0x98C00000      //RCC2 divisao por 50
#define config_3MHZ                 0x9FC00000      //RCC2 divisao maxima(64) pag 224
//--------------------------------------------------------------------------//
#define portalA_BASE                0x40004000
#define portalB_BASE                0x40005000
#define portalC_BASE                0x40006000
#define portalD_BASE                0x40007000
#define portalE_BASE                0x40024000
#define portalF_BASE                0x40025000
//--------------------------------------------------------------------------//
#define portalA_base                0x40004000
#define portalB_base                0x40005000
#define portalC_base                0x40006000
#define portalD_base                0x40007000
#define portalE_base                0x40024000
#define portalF_base                0x40025000
//--------------------------------------------------------------------------//
#define portalGPIO_a                0x01
#define portalGPIO_b                0x02
#define portalGPIO_c                0x04
#define portalGPIO_d                0x08
#define portalGPIO_e                0x10
#define portalGPIO_f                0x20
//--------------------------------------------------------------------------//
#define pino0                       0x01
#define pino1                       0x02
#define pino2                       0x04
#define pino3                       0x08
#define pino4                       0x10
#define pino5                       0x20
#define pino6                       0x40
#define pino7                       0x80
//--------------------------------------------------------------------------//
#define GPIO_O_DIR                  0x400
#define GPIO_O_DR2R                 0x500
#define GPIO_O_DEN                  0x51C
#define GPIO_O_PUR                  0x510
#define GPIO_O_DATA                 0x000
//--------------------------------------------------------------------------//
#define EN0                         0xE000E100
#define EN1                         0xE000E104
#define EN2                         0xE000E108
#define EN3                         0xE000E10C
#define EN4                         0xE000E110
//--------------------------------------------------------------------------//
#define int_port_A                  0
#define int_port_B                  1
#define int_port_C                  2
#define int_port_D                  3
#define int_port_E                  4
#define int_port_F                  30
#define GPIO_O_IBE                  0x408
#define GPIO_O_IS                   0x404
#define GPIO_O_IEV                  0x40C
//--------------------------------------------------------------------------//
#define GPIO_FallingEdge            0x0
#define GPIO_RisingEdge             0x4
#define GPIO_BothEdges              0x1
#define GPIO_LowLevel               0x2
#define GPIO_HighLevel              0x6
//--------------------------------------------------------------------------//
#define GPIO_O_IM                   0x410
#define NVIC_ST_CTRL                0xE000E010
#define NVIC_ST_CTRL_CLK_SRC        0x4
#define NVIC_ST_CTRL_ENABLE         0x1
#define NVIC_ST_CTRL_INTEN          0x2
#define NVIC_ST_RELOAD              0xE000E014
//--------------------------------------------------------------------------//
#define GPIO_O_LOCK                 0x520
#define GPIO_O_CR                   0x524
#define GPIO_LOCK_KEY               0x4C4F434B
//--------------------------------------------------------------------------//
//----------------------------------------------------------//
unsigned int vector_numbers[18]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71,0x3E,0x31};
unsigned int vector_digits[4]={0x8C,0x4C,0xC8,0xC4}; // sinal baixo funciona
int um_minuto_anodo = 3000;
//----------------------------------------------------------//
// **** VAR Globais ************************
int systick_cronometro = 1500000,systick_relogio = 90000000;

const float timer_duvidoso_mili_80MHz = 3800000;  // ~um segundo
const float timer_doopler = 0.35;

//usado para varredura da matrix de botao se os botoes que representa as linhas estivem de PULLUP
int vector_matrix[4] = {0x0E,0x0D,0x0B,0x07};


unsigned int n1=0, n2=0, n3=0, n4=0, speed=1, i=0, prox=0, segundo=0;

// **** FIM Var Globais ***********************

// Deve ser chamada para todo gate que venha a ser usado (na main)
void habilita_clockGPIO(uint32_t portalGPIO){
    ESC_REG(SYSCTL_RCGCGPIO) |= portalGPIO;
}
//--------------------------------------------------------------------------//
void delay_system(float mS){
    mS = (mS/1000) * timer_duvidoso_mili_80MHz;
    while(mS > 0)
        mS--;
}
//--------------------------------------------------------------------------//
void configuraPino_saida(uint32_t portal, uint8_t pino){
    ESC_REG(portal+GPIO_O_DIR) |= pino;
    ESC_REG(portal+GPIO_O_DR2R) |= pino;
    ESC_REG(portal+GPIO_O_DEN) |= pino;
}
//--------------------------------------------------------------------------//
void configuraPino_entrada(uint32_t portal, uint8_t pino){
    ESC_REG(portal+GPIO_O_DIR) &= ~(pino);
    ESC_REG(portal+GPIO_O_DR2R) |= pino;
    ESC_REG(portal+GPIO_O_DEN) |= pino;
}
//--------------------------------------------------------------------------//
uint32_t GPIO_leitura(uint32_t portal, uint8_t pino){
    return(ESC_REG(portal + (GPIO_O_DATA+(pino<<2))));
}
//--------------------------------------------------------------------------//
void GPIO_escrita(uint32_t portal, uint8_t pino, uint8_t valor){
    ESC_REG(portal + (GPIO_O_DATA+(pino<<2))) = valor;
}
//--------------------------------------------------------------------------//
// Desbloqueia a trava GPIO do registrador usando programação direta com o registrador.
void unlock_GPIO(uint32_t portal){
    ESC_REG(portal + GPIO_O_LOCK) = GPIO_LOCK_KEY;
    ESC_REG(portal + GPIO_O_CR) = 0x01;
}
//--------------------------------------------------------------------------//
// Bloqueia a trava GPIO novamente.
void lock_GPIO(uint32_t portal){
    ESC_REG(portal + GPIO_O_LOCK) = 0;
}
//--------------------------------------------------------------------------//
// Ativa os segmentos pra ligar o número entrado
void numero(int i){
    GPIO_escrita(portalE_BASE, pino0|pino1|pino2|pino3, vector_numbers[i]);
    GPIO_escrita(portalC_BASE, pino4|pino5|pino6|pino7, vector_numbers[i]);
}
//--------------------------------------------------------------------------//
// Ativa o digito entrado e desativa os outros
void digito(int i){
    GPIO_escrita(portalB_BASE, pino6|pino7, vector_digits[i]);
    GPIO_escrita(portalD_BASE, pino3|pino2, vector_digits[i]);
}
//--------------------------------------------------------------------------//
void limpa_display(void)
{
    GPIO_escrita(portalB_base, pino6|pino7, 0x00|0x00);
    GPIO_escrita(portalD_base, pino3|pino2|pino6, 0x00|0x00|pino6);
    GPIO_escrita(portalE_base, pino0|pino1|pino2|pino3, 0x00|0x00|0x00|0x00);
    GPIO_escrita(portalC_base, pino4|pino5|pino6|pino7, 0x00|0x00|0x00|0x00);
}
//--------------------------------------------------------------------------//
void habilita_interrupcao_global(void)
{
    //passo3
    __asm( " mrs r0, PRIMASK\n"
            " cpsie i\n"
            " bx lr\n");
}
//-----------------------------------------------------------------------//
void habilitaInterrupcao(uint32_t ui32Interrupcao){
    //passo2
    if(ui32Interrupcao < 32){
        ESC_REG(EN0)    |= 1<<ui32Interrupcao;
    }
}
//-----------------------------------------------------------------------//
void configInt_GPIO(uint32_t portal, uint8_t pino, uint32_t tipo){
    ESC_REG(portal + GPIO_O_IBE) = ((tipo & 1) ?
            (ESC_REG(portal + GPIO_O_IBE) | pino) :
            (ESC_REG(portal + GPIO_O_IBE) & ~(pino)));
    ESC_REG(portal + GPIO_O_IS) = ((tipo & 2) ?
            (ESC_REG(portal + GPIO_O_IS) | pino) :
            (ESC_REG(portal + GPIO_O_IS) & ~(pino)));
    ESC_REG(portal + GPIO_O_IEV) = ((tipo & 4) ?
            (ESC_REG(portal + GPIO_O_IEV) | pino) :
            (ESC_REG(portal + GPIO_O_IEV) & ~(pino)));
}
//-----------------------------------------------------------------------//
void habilitaInt_GPIO(uint32_t portal, uint8_t pino){
    //passo1 Device Arm
    ESC_REG(portal + GPIO_O_IM) |= pino;
}
//-----------------------------------------------------------------------//
void desabilitaInt_GPIO(uint32_t portal, uint8_t pino){
    ESC_REG(portal + GPIO_O_IM) &= ~(pino);
}
//-----------------------------------------------------------------------//
//-----------------------------------------------------------------------//
// chamar sempre no inicio de uma trata
void limpaInt_GPIO(uint32_t portal, uint8_t pino)
{
    ESC_REG(portal + GPIO_O_ICR) = pino;
}
//-----------------------------------------------------------------------//
void escreve_4_digitos(int n4,int n3,int n2,int n1){
    // [ - - - n1]
    digito(3);
    numero(n1);
    delay_system(timer_doopler);

    limpa_display();
    delay_system(timer_doopler);

    // [ - - n2 -]
    digito(2);
    numero(n2);
    delay_system(timer_doopler);

    limpa_display();
    delay_system(timer_doopler);

    // [ - n3 - -]
    digito(1);
    numero(n3);
    delay_system(timer_doopler);

    limpa_display();
    delay_system(timer_doopler);

    // [ n4 - - -]
    digito(0);
    numero(n4);
    delay_system(timer_doopler);

    limpa_display();
    delay_system(timer_doopler);
}

int questao_8(void){
    escreve_4_digitos(n4,n3,n2,n1);
    int c=0, l=0, pega_num = 0;
    for(c=0;c<4;c++)
    {
        for(l=0;l<4;l++)
        {
            GPIO_escrita(portalF_base, pino0|pino1|pino2|pino3, vector_matrix[c]);

            if(l==0 && GPIO_leitura(portalF_base, pino4)!= pino4)
            {
                pega_num=c;
                delay_system(50); // deboucer tecnica 1
            }
            if(l==1 && GPIO_leitura(portalB_base, pino0)!= pino0)
            {
                pega_num=c+4;
                delay_system(50);// deboucer tecnica 1
            }
            if(l==2 && GPIO_leitura(portalB_base, pino1)!= pino1)
            {
                pega_num=c+8;
                delay_system(50);// deboucer tecnica 1
            }
            if(l==3 && GPIO_leitura(portalB_base, pino5)!= pino5)
            {
                pega_num=c+12;
                delay_system(50);// deboucer tecnica 1
            }
        }
    }
    return(pega_num);
}

int first = 0, abc=0, c=0, l=0, cont = 0;
void matrix_botao(void)
{
    int j=0;
    while(1)
    {
        if(cont == 4){
            unlock_GPIO(portalF_base);
            configuraPino_entrada(portalF_base,pino0);

            configuraPino_entrada(portalF_base, pino4|pino0);
            ESC_REG(portalF_base+GPIO_O_PUR) |= pino4;
            ESC_REG(portalF_base+GPIO_O_PUR) |= pino0;

            lock_GPIO(portalF_base);

            habilita_interrupcao_global();
            habilitaInterrupcao(int_port_F);
            configInt_GPIO(portalF_base, pino4|pino0, GPIO_FallingEdge);
            habilitaInt_GPIO(portalF_base, pino4|pino0);
        }
        if(!first)
        {
            for(c=0;c<4;c++)
            {
                {
                    for(l=0;l<4;l++)
                    {
                        GPIO_escrita(portalF_base, pino0|pino1|pino2|pino3, vector_matrix[c]);
                        if(l==0 && GPIO_leitura(portalF_base, pino4)!= pino4)
                        {
                            n4=c;
                            first=1;
                            delay_system(50);
                            cont++;
                        }
                        if(l==1 && GPIO_leitura(portalB_base, pino0)!= pino0)
                        {
                            n4=c+4;
                            first=1;
                            delay_system(50);
                            cont++;
                        }
                        if(l==2 && GPIO_leitura(portalB_base, pino1)!= pino1)
                        {
                            n4=c+8;
                            first=1;
                            delay_system(50);
                            cont++;
                        }
                        if(l==3 && GPIO_leitura(portalB_base, pino5)!= pino5)
                        {
                            n4=c+12;
                            first=1;
                            delay_system(50);
                            cont++;
                        }
                    }
                }
            }
        }
        else
        {
            for(c=0;c<4;c++)
            {
                escreve_4_digitos(n1,n2,n3,n4);
                for(l=0;l<4;l++)
                {
                    GPIO_escrita(portalF_base, pino0|pino1|pino2|pino3, vector_matrix[c]);
                    if(l==0 && GPIO_leitura(portalF_base, pino4)!= pino4)
                    {
                        if(abc){
                            n1=0;n2=0;n3=0;n4=0;abc=0;
                        }
                        n1=n2;n2=n3;n3=n4;
                        n4=c;
                        delay_system(50);
                        cont++;
                    }
                    if(l==1 && GPIO_leitura(portalB_base, pino0)!= pino0)
                    {
                        if(abc){
                            n1=0;n2=0;n3=0;n4=0;abc=0;
                        }

                        n1=n2;n2=n3;n3=n4;
                        n4=c+4;
                        delay_system(50);
                        cont++;
                    }
                    if(l==2 && GPIO_leitura(portalB_base, pino1)!= pino1)
                    {
                        if(abc){
                            n1=0;n2=0;n3=0;n4=0;abc=0;
                        }
                        n1=n2;n2=n3;n3=n4;
                        n4=c+8;
                        delay_system(50);
                        cont++;
                    }
                    if(l==3 && GPIO_leitura(portalB_base, pino5)!= pino5)
                    {
                        if(abc){
                            n1=0;n2=0;n3=0;n4=0;abc=0;
                        }
                        n1=n2;n2=n3;n3=n4;
                        n4=c+12;
                        delay_system(50);
                        cont++;
                    }
                }
            }
        }
    }
}

void trataIntGPIOF(void){

    limpaInt_GPIO(portalF_base, pino4|pino0);
    int num_gordo = 0, soma = 0;
    if(GPIO_leitura(portalF_base,pino4)!= pino4){
        delay_system(45);
        num_gordo = (n1 * (10 * 10 * 10) + n2 * (10 * 10) + n3 * 10 + n4);
        if(num_gordo > 9999){
            n1 = 0;
            n2 = 16;
            n3 = 14;
            n4 = 17;
            abc = 1;
            cont=0;
        }else{
            n4 = num_gordo % 16;
            n3 = (num_gordo%(16*16)-n1)/16;
            n2 = (num_gordo %(16*16*16)-n1-n2)/(16*16);
            n1 = (num_gordo-n1-n2-n3)/(16*16*16);
            cont = 0;
        }
        delay_system(45);
        escreve_4_digitos(n1,n2,n3,n4);
        escreve_4_digitos(n1,n2,n3,n4);
        escreve_4_digitos(n1,n2,n3,n4);
        escreve_4_digitos(n1,n2,n3,n4);
        escreve_4_digitos(n1,n2,n3,n4);

    }
    //Conversão Hexa -> Deci
    if(GPIO_leitura(portalF_base,pino0)!= pino0){
        delay_system(45);
        num_gordo = (n1 * (16 * 16 * 16) + n2 * (16 * 16) + n3 * 16 + n4);
        if(num_gordo >= 10000){
            n1 = 0;
            n2 = 16;
            n3 = 14;
            n4 = 17;
            abc = 1;
            cont=0;
        }else{
            n1 = num_gordo/1000;
            n2 = (num_gordo - n1 * 1000) / 100;
            n3 = (num_gordo - (n1 * 1000 + n2 * 100)) / 10;
            soma = (n1 * 1000) + (n2 * 100) + (n3 * 10);
            n4 = num_gordo - soma;
            cont=0;
        }
    }
}
//--------------------------------------------------------------------------//
int main(void){
    volatile uint32_t ui32Loop;
    //habilita_clockGPIO(portalGPIO_f);

    // Faz leitura dummy para efeito de atraso
    ui32Loop = ESC_REG(SYSCTL_RCGC2_R);

    //configuraPino_saida(portalF_BASE, pino2);


    habilita_clockGPIO(portalGPIO_e|portalGPIO_c|portalGPIO_d | portalGPIO_b| portalGPIO_f);
    configuraPino_saida(portalC_BASE,pino4|pino5|pino6|pino7);
    configuraPino_saida(portalE_BASE,pino0|pino1|pino2|pino3);
    configuraPino_saida(portalB_BASE, pino6|pino7);
    configuraPino_saida(portalD_BASE, pino2|pino3|pino6);

    unlock_GPIO(portalF_base);
    // pinos matrix de botao
    configuraPino_saida(portalF_base, pino0|pino1|pino2|pino3);

    configuraPino_entrada(portalF_base, pino4);
    ESC_REG(portalF_base+GPIO_O_PUR) |= pino4;
    configuraPino_entrada(portalB_base,pino0|pino1|pino5);
    ESC_REG(portalB_base+GPIO_O_PUR) |= pino0|pino1|pino5;

    lock_GPIO(portalF_base);

    /*habilita_interrupcao_global();
    habilitaInterrupcao(int_port_F);
    configInt_GPIO(portalF_base, pino4|pino0, GPIO_FallingEdge);
    habilitaInt_GPIO(portalF_base, pino4|pino0);*/

    // Entrar com o tempo inicial. O último parâmetro é um divisor de tempo - 10 fará com que 1 minuto se passe em 6 segundos.
    // (Primeiro digito da hora, segundo digito da hora, primeiro digito dos minutos, segundo digito dos minutos, 0 ou 1 para tempo padrão)
    //relogio(0,0,0,0,10);
    matrix_botao();
    while(1){
    }
}
